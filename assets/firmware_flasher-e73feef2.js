import{e as Oe,G as _,C as he,b as L,c as l,M as E,s as g,T as f,$ as t,d as D,A as ue,a as Ne,f as H,E as De,t as N}from"./DarkTheme-2fd54461.js";import{F as A,M as Se,a as B,r as Fe,W as z,b as Re,d as Ue,N as ge,e as K,P as V,s as j,B as $e,u as Ge,g as He,f as Ve}from"./main-ef562b84.js";import{S as ze}from"./Sponsor-964f3033.js";import{g as Ke}from"./generate_filename-f7fae895.js";const Ye=134227968,pe=16384;function xe(r,e){let a=0;for(;a<r.data.length&&e>=r.data[a].address+r.data[a].bytes;a++);const i={lineIndex:a};return r.data[a]&&e>=r.data[a].address&&(i.byteIndex=e-r.data[a].address),i}function _e(r,e){let a=0;for(let i=0;i<4;i++)a+=r.data[e.lineIndex].data[e.byteIndex++]<<8*i,e.byteIndex>=r.data[e.lineIndex].bytes&&(e.lineIndex++,e.byteIndex=0);return a}function qe(r){const e={},a=xe(r,Ye);if(a.byteIndex!==void 0)return e.startAddress=_e(r,a),e.endAddress=_e(r,a),e}function We(r,e,a){let i=a;const o=xe(r,i);if(o.byteIndex!==void 0)throw new Error("Configuration area in firmware not free.");let c=0;for(;c<e.length;){const u=e.length-c,p={address:i,bytes:pe>u?u:pe,data:[]};if(r.data[o.lineIndex]&&p.address+p.bytes>r.data[o.lineIndex].address)throw new Error("Aborting data generation, free area too small.");for(let h=0;h<p.bytes;h++)p.data.push(e.charCodeAt(c++));i=i+p.bytes,r.data.splice(o.lineIndex++,0,p)}r.bytes_total+=e.length}const me="Custom defaults inserted in";class Xe{insertConfig(e,a){console.time(me);const i=`# Betaflight
${a}\0`,o=qe(e);if(!o||o.endAddress-o.startAddress===0)return!1;if(i.length>=o.endAddress-o.startAddress)throw new Error(`Custom defaults area too small (${o.endAddress-o.startAddress} bytes), ${i.length+1} bytes needed.`);return We(e,i,o.startAddress),console.timeEnd(me),!0}}const be="HEX_PARSER - File parsed in";async function je(r){console.time(be),r=r.split(`
`),r[r.length-1]==""&&r.pop();let e=!0;const a={data:[],end_of_file:!1,bytes_total:0,start_linear_address:0};let i=0,o=0;for(let c=0;c<r.length&&e;c++){const u=parseInt(r[c].substr(1,2),16),p=parseInt(r[c].substr(3,4),16),h=parseInt(r[c].substr(7,2),16),b=r[c].substr(9,u*2),F=parseInt(r[c].substr(9+u*2,2),16);switch(h){case 0:(p!==o||o===0)&&a.data.push({address:i+p,bytes:0,data:[]}),o=p+u;let k=u+parseInt(r[c].substr(3,2),16)+parseInt(r[c].substr(5,2),16)+h;for(let O=0;O<u*2;O+=2){const y=parseInt(b.substr(O,2),16),R=a.data.length-1;a.data[R].data.push(y),a.data[R].bytes++,k+=y,a.bytes_total++}k=~k+1&255,k!=F&&(e=!1);break;case 1:a.end_of_file=!0;break;case 2:parseInt(b,16)!=0&&console.log("extended segment address record found - NOT IMPLEMENTED !!!");break;case 3:parseInt(b,16)!=0&&console.log("start segment address record found - NOT IMPLEMENTED !!!");break;case 4:i=(parseInt(b.substr(0,2),16)<<24|parseInt(b.substr(2,2),16)<<16)>>>0;break;case 5:a.start_linear_address=parseInt(b,16);break}}return console.timeEnd(be),a.end_of_file&&e?a:null}const P=Oe();function ie(r){Fe(r.detail.buffer)}function Qe(){P.disconnect(r=>{console.log("Disconnected",r),E.clearListeners(),this.onTimeoutCallback()}),E.disconnect_cleanup()}class Ze{constructor(){this.baud=void 0,this.port=void 0,this.onConnectCallback=void 0,this.onTimeoutCallback=void 0,this.onDisconnectCallback=void 0}handleConnect(e){if(e){A.resetState(),_.timeout_add("msp_connector",function(){he.connectionValid||(L(l.getMessage("noConfigurationReceived")),Qe())},1e4),P.removeEventListener("receive",ie),P.addEventListener("receive",ie);const a=new Se;E.listen(a.process_data.bind(a)),E.send_message(B.MSP_API_VERSION,!1,!1,()=>{he.connectionValid=!0,_.timeout_remove("msp_connector"),console.log("Connected"),this.onConnectCallback()})}else L(l.getMessage("serialPortOpenFail")),this.onFailureCallback()}handleDisconnect(e){console.log("Disconnected",e),P.removeEventListener("receive",ie),P.removeEventListener("connect",a=>this.handleConnect(a.detail)),P.removeEventListener("disconnect",a=>this.handleDisconnect(a)),E.clearListeners(),E.disconnect_cleanup()}connect(e,a,i,o,c){this.port=e,this.baud=a,this.onConnectCallback=i,this.onTimeoutCallback=o,this.onFailureCallback=c,P.removeEventListener("connect",u=>this.handleConnect(u.detail)),P.addEventListener("connect",u=>this.handleConnect(u.detail),{once:!0}),P.removeEventListener("disconnect",u=>this.handleDisconnect(u)),P.addEventListener("disconnect",u=>this.handleDisconnect(u),{once:!0}),P.connect(this.port,{baudRate:this.baud})}disconnect(e){this.onDisconnectCallback=e,P.disconnect(a=>{E.clearListeners(),console.log("Disconnected",a),this.onDisconnectCallback(a)}),E.disconnect_cleanup()}}function ve(r){Fe(r.detail.buffer)}function Je(){_.connect_lock=!1,console.log("Looking for capabilities via MSP failed"),f.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID)}function et(){_.connect_lock=!1,f.firmware_flasher.refresh()}class tt{constructor(){this.baud=null,this.options={},this.callback=null,this.hex=null,this.verify_hex=[],this.receive_buffer=[],this.bytesToRead=0,this.read_callback=null,this.upload_time_start=0,this.upload_process_alive=!1,this.mspConnector=new Ze,this.status={ACK:121,NACK:31},this.command={get:0,get_ver_r_protect_s:1,get_ID:2,read_memory:17,go:33,write_memory:49,erase:67,extended_erase:68,write_protect:99,write_unprotect:115,readout_protect:130,readout_unprotect:146},this.available_flash_size=0,this.page_size=0,this.useExtendedErase=!1,this.rebootMode=0,this.handleMSPConnect=this.handleMSPConnect.bind(this)}handleConnect(e){console.log("Connected to serial port",e.detail,e),e?(_.connect_lock=!0,this.initialize()):L(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){console.log("Waiting for DFU connection"),g.removeEventListener("connect",a=>this.handleConnect(a.detail)),g.removeEventListener("disconnect",a=>this.handleDisconnect(a.detail)),e&&this.rebootMode?setTimeout(()=>{this.rebootMode&&(console.log("STM32 Requesting permission for device"),z.requestPermission().then(a=>{a!=null?console.log("DFU request permission granted",a):(console.error("DFU request permission denied"),this.rebootMode=0,_.connect_lock=!1)}).catch(a=>{console.error("DFU request permission failed",a),this.rebootMode=0,_.connect_lock=!1}))},3e3):_.connect_lock=!1}prepareSerialPort(){g.removeEventListener("connect",e=>this.handleConnect(e.detail)),g.addEventListener("connect",e=>this.handleConnect(e.detail),{once:!0}),g.removeEventListener("disconnect",e=>this.handleDisconnect(e.detail)),g.addEventListener("disconnect",e=>this.handleDisconnect(e.detail),{once:!0})}reboot(){const e=[];e.push8(this.rebootMode),setTimeout(()=>{E.promise(B.MSP_SET_REBOOT,e).then(()=>{this.mspConnector.disconnect(a=>{console.log("Disconnecting from MSP",a),this.handleDisconnect(a)})}),console.log("Reboot request received by device")},100)}onAbort(){_.connect_lock=!1,this.rebootMode=0,console.log("User cancelled because selected target does not match verified board"),this.reboot(),f.firmware_flasher.refresh()}lookingForCapabilitiesViaMSP(){console.log("Looking for capabilities via MSP"),E.promise(B.MSP_BOARD_INFO).then(()=>{Re(A.CONFIG.targetCapabilities,A.TARGET_CAPABILITIES_FLAGS.HAS_FLASH_BOOTLOADER)?(L(l.getMessage("deviceRebooting_flashBootloader")),console.log("flash bootloader detected"),this.rebootMode=4):(L(l.getMessage("deviceRebooting_romBootloader")),console.log("no flash bootloader detected"),this.rebootMode=1);const e=f.firmware_flasher.selectedBoard!=="0"?f.firmware_flasher.selectedBoard:"NONE",a=A.CONFIG.boardName?A.CONFIG.boardName:"UNKNOWN";try{e!==a&&!f.firmware_flasher.localFirmwareLoaded?f.firmware_flasher.showDialogVerifyBoard(e,a,this.reboot.bind(this),this.onAbort.bind(this)):this.reboot()}catch(i){console.error(i),this.reboot()}})}handleMSPConnect(){L(l.getMessage("apiVersionReceived",[A.CONFIG.apiVersion])),this.lookingForCapabilitiesViaMSP()}connect(e,a,i,o,c){this.hex=i,this.port=e,this.baud=a,this.callback=c,this.serialOptions=o,this.mspOptions={no_reboot:!1,reboot_baud:!1,erase_chip:!1},o.no_reboot?this.mspOptions.no_reboot=!0:this.mspOptions.reboot_baud=o.reboot_baud,o.erase_chip&&(this.mspOptions.erase_chip=!0),this.options.no_reboot?(this.prepareSerialPort(),g.connect(e,{baudRate:this.baud,parityBit:"even",stopBits:"one"})):(this.rebootMode=0,_.connect_lock=!0,f.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),g.addEventListener("disconnect",u=>this.handleDisconnect(u.detail),{once:!0}),this.mspConnector.connect(this.port,this.mspOptions.reboot_baud,this.handleMSPConnect,Je,et))}initialize(){console.log(":exploding_head:"),this.receive_buffer=[],this.verify_hex=[],this.upload_time_start=new Date().getTime(),this.upload_process_alive=!1,f.firmware_flasher.flashingMessage(null,f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t('select[name="release"]').prop("disabled",!0),g.removeEventListener("receive",ve),g.addEventListener("receive",ve),_.interval_add("STM32_timeout",()=>{this.upload_process_alive?this.upload_process_alive=!1:(console.log("STM32 - timed out, programming failed ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32TimedOut"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),_.interval_remove("STM32_timeout"),this.upload_procedure(99))},2e3),console.log("STM32 - Initialization done, starting upload procedure"),this.upload_procedure(1)}read(e){const a=new Uint8Array(e.data);for(const i of a)this.receive_buffer.push(i);if(this.receive_buffer.length>=this.bytesToRead&&this.bytesToRead!=0){const i=this.receive_buffer.slice(0,this.bytesToRead);this.receive_buffer.splice(0,this.bytesToRead),this.bytesToRead=0,this.read_callback(i)}}retrieve(e,a){if(this.receive_buffer.length>=e){const i=this.receive_buffer.slice(0,e);this.receive_buffer.splice(0,e),a(i)}else this.bytesToRead=e,this.read_callback=a}send(e,a,i){this.upload_process_alive=!0;const o=new ArrayBuffer(e.length);new Uint8Array(o).set(e),this.bytesToRead=a,this.read_callback=i,this.receive_buffer=[],g.send(o)}verify_response(e,a){if(e!==a[0]){const i=`STM32 Communication failed, wrong response, expected: ${e} (0x${e.toString(16)}) received: ${a[0]} (0x${a[0].toString(16)})`;return console.error(i),f.firmware_flasher.flashingMessage(l.getMessage("stm32WrongResponse",[e,e.toString(16),a[0],a[0].toString(16)]),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),this.upload_procedure(99),!1}return!0}verify_chip_signature(e){switch(e){case 1042:console.log("Chip recognized as F1 Low-density");break;case 1040:console.log("Chip recognized as F1 Medium-density"),this.available_flash_size=131072,this.page_size=1024;break;case 1044:this.available_flash_size=262144,this.page_size=2048,console.log("Chip recognized as F1 High-density");break;case 1048:console.log("Chip recognized as F1 Connectivity line");break;case 1056:console.log("Chip recognized as F1 Medium-density value line");break;case 1064:console.log("Chip recognized as F1 High-density value line");break;case 1072:console.log("Chip recognized as F1 XL-density value line");break;case 1046:console.log("Chip recognized as L1 Medium-density ultralow power");break;case 1078:console.log("Chip recognized as L1 High-density ultralow power");break;case 1063:console.log("Chip recognized as L1 Medium-density plus ultralow power");break;case 1041:console.log("Chip recognized as F2 STM32F2xxxx");break;case 1088:console.log("Chip recognized as F0 STM32F051xx");break;case 1092:console.log("Chip recognized as F0 STM32F050xx");break;case 1043:console.log("Chip recognized as F4 STM32F40xxx/41xxx");break;case 1049:console.log("Chip recognized as F4 STM32F427xx/437xx, STM32F429xx/439xx");break;case 1074:console.log("Chip recognized as F3 STM32F37xxx, STM32F38xxx");break;case 1058:console.log("Chip recognized as F3 STM32F30xxx, STM32F31xxx"),this.available_flash_size=262144,this.page_size=2048;break;default:console.log(`Chip NOT recognized: ${e}`);break}return this.available_flash_size>0?this.hex.bytes_total<this.available_flash_size?!0:(console.log(`Supplied hex is bigger then flash available on the chip, HEX: ${this.hex.bytes_total} bytes, limit = ${this.available_flash_size} bytes`),!1):(console.log(`Chip NOT recognized: ${e}`),!1)}verify_flash(e,a){for(let i=0;i<e.length;i++)if(e[i]!==a[i])return console.log(`Verification failed on byte: ${i} expected: 0x${e[i].toString(16)} received: 0x${a[i].toString(16)}`),!1;return console.log(`Verification successful, matching: ${e.length} bytes`),!0}upload_procedure(e){switch(e){case 1:{f.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let a=0;_.interval_add("stm32_initialize_mcu",()=>{this.send([127],1,i=>{i[0]===127||i[0]===this.status.ACK||i[0]===this.status.NACK?(_.interval_remove("stm32_initialize_mcu"),console.log("STM32 - Serial interface initialized on the MCU side"),this.upload_procedure(2)):(f.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),_.interval_remove("stm32_initialize_mcu"),this.upload_procedure(99))}),a++>3&&(console.log("STM32 - no response from bootloader, disconnecting"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ResponseBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),_.interval_remove("stm32_initialize_mcu"),_.interval_remove("STM32_timeout"),this.upload_procedure(99))},250,!0);break}case 2:{this.send([this.command.get,255],2,a=>{this.verify_response(this.status.ACK,a)&&this.retrieve(a[1]+1+1,i=>{console.log(`STM32 - Bootloader version: ${(parseInt(i[0].toString(16))/10).toFixed(1)}`),this.useExtendedErase=i[7]===this.command.extended_erase,this.upload_procedure(3)})});break}case 3:this.send([this.command.get_ID,253],2,a=>{this.verify_response(this.status.ACK,a)&&this.retrieve(a[1]+1+1,i=>{const o=i[0]<<8|i[1];console.log(`STM32 - Signature: 0x${o.toString(16)}`),this.verify_chip_signature(o)?this.upload_procedure(4):this.upload_procedure(99)})});break;case 4:{if(this.useExtendedErase){this.options.erase_chip?(console.log("Executing global chip erase (via extended erase)"),f.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,i=>{this.verify_response(this.status.ACK,i)&&this.send([255,255,0],1,o=>{this.verify_response(this.status.ACK,o)&&(console.log("Executing global chip extended erase: done"),this.upload_procedure(5))})})):(console.log("Executing local erase (via extended erase)"),f.firmware_flasher.flashingMessage(l.getMessage("stm32LocalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,i=>{if(this.verify_response(this.status.ACK,i)){const o=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,c=Math.ceil(o/this.page_size),u=[];let p=0,h;h=c-1>>8,u.push(h),p^=h,h=c-1&255,u.push(h),p^=h;for(let b=0;b<c;b++)h=b>>8,u.push(h),p^=h,h=b&255,u.push(h),p^=h;u.push(p),console.log(`Erasing. pages: 0x00 - 0x${c.toString(16)}, checksum: 0x${p.toString(16)}`),this.send(u,1,b=>{this.verify_response(this.status.ACK,b)&&(console.log("Erasing: done"),this.upload_procedure(5))})}}));break}this.options.erase_chip?(console.log("Executing global chip erase"),f.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,i=>{this.verify_response(this.status.ACK,i)&&this.send([255,0],1,o=>{this.verify_response(this.status.ACK,o)&&(console.log("Erasing: done"),this.upload_procedure(5))})})):(console.log("Executing local erase"),f.firmware_flasher.flashingMessage(l.getMessage("stm32LocalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,i=>{if(this.verify_response(this.status.ACK,i)){const o=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,c=Math.ceil(o/this.page_size),u=[];let p=c-1;u.push(c-1);for(let h=0;h<c;h++)u.push(h),p^=h;u.push(p),this.send(u,1,h=>{this.verify_response(this.status.ACK,h)&&(console.log("Erasing: done"),this.upload_procedure(5))})}}));break}case 5:{console.log("Writing data ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32Flashing"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let a=this.hex.data.length-1,i=0,o=this.hex.data[i].address,c=0,u=0;const p=()=>{if(c<this.hex.data[i].bytes){const h=c+256<=this.hex.data[i].bytes?256:this.hex.data[i].bytes-c;this.send([this.command.write_memory,206],1,b=>{if(this.verify_response(this.status.ACK,b)){const F=[o>>24,o>>16,o>>8,o],k=F[0]^F[1]^F[2]^F[3];this.send([F[0],F[1],F[2],F[3],k],1,O=>{if(this.verify_response(this.status.ACK,O)){const y=Array.from(h+2);y[0]=h-1;let R=y[0];for(let I=0;I<h;I++)y[I+1]=this.hex.data[i].data[c],R^=this.hex.data[i].data[c],c++;y[y.length-1]=R,o+=h,u+=h,this.send(y,1,I=>{this.verify_response(this.status.ACK,I)&&p()}),f.firmware_flasher.flashProgress(Math.round(u/(this.hex.bytes_total*2)*100))}})}})}else i<a?(i++,o=this.hex.data[i].address,c=0,p()):(console.log("Writing: done"),this.upload_procedure(6))};p();break}case 6:{console.log("Verifying data ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32Verifying"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);const a=this.hex.data.length-1;let i=0,o=this.hex.data[i].address,c=0,u=0;for(let h=0;h<=a;h++)this.verify_hex.push([]);const p=()=>{if(c<this.hex.data[i].bytes){const h=c+256<=this.hex.data[i].bytes?256:this.hex.data[i].bytes-c;this.send([this.command.read_memory,238],1,b=>{if(this.verify_response(this.status.ACK,b)){const F=[o>>24,o>>16,o>>8,o],k=F[0]^F[1]^F[2]^F[3];this.send([F[0],F[1],F[2],F[3],k],1,O=>{if(this.verify_response(this.status.ACK,O)){const y=h-1;this.send([y,~y&255],1,R=>{this.verify_response(this.status.ACK,R)&&this.retrieve(h,I=>{for(const U of I)this.verify_hex[i].push(U);o+=h,c+=h,u+=h,p()})}),f.firmware_flasher.flashProgress(Math.round((this.hex.bytes_total+u)/(this.hex.bytes_total*2)*100))}})}})}else if(i<a)i++,o=this.hex.data[i].address,c=0,p();else{let h=!0;for(let b=0;b<=a&&(h=this.verify_flash(this.hex.data[b].data,this.verify_hex[b]),!!h);b++);h?(console.log("Programming: SUCCESSFUL"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingSuccessful"),f.firmware_flasher.FLASH_MESSAGE_TYPES.VALID),D("showNotifications")&&ge.showNotification("Betaflight Configurator",{body:l.getMessage("programmingSuccessfulNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(7)):(console.log("Programming: FAILED"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),D("showNotifications")&&ge.showNotification("Betaflight Configurator",{body:l.getMessage("programmingFailedNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(99))}};p();break}case 7:{console.log("Sending GO command: 0x8000000"),this.send([this.command.go,222],1,a=>{if(this.verify_response(this.status.ACK,a)){const o=[8,2048,524288,134217728],c=o[0]^o[1]^o[2]^o[3];this.send([o[0],o[1],o[2],o[3],c],1,u=>{this.verify_response(this.status.ACK,u)&&this.upload_procedure(99)})}});break}case 99:{_.interval_remove("STM32_timeout"),g.connectionId?g.disconnect(this.cleanup):this.cleanup();break}}}cleanup(){Ue.reset(),_.connect_lock=!1,t('select[name="release"]').prop("disabled",!1);const e=new Date().getTime()-this.upload_time_start;console.log(`Script finished after: ${e/1e3} seconds`),this.callback&&this.callback()}}const J=new tt;class st{constructor(){this.outputHistory="",this.callback=null}handleConnect(e){console.log("Connected to serial port:",e),e?(g.removeEventListener("receive",this.readSerialAdapter),g.addEventListener("receive",this.readSerialAdapter.bind(this)),this.run()):L(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){L(l.getMessage(e.detail?"serialPortClosedOk":"serialPortClosedFail")),g.removeEventListener("receive",this.readSerialAdapter),g.removeEventListener("connect",this.handleConnect),g.removeEventListener("disconnect",this.handleDisconnect)}readSerialAdapter(e){const a=new Uint8Array(e.detail.buffer);for(const i of a){const o=String.fromCharCode(i);this.outputHistory+=o}}onClose(){g.addEventListener("disconnect",this.handleDisconnect.bind(this),{once:!0}),g.disconnect()}async save(e){console.log("Saving backup");const a="cli_backup",i="txt",o=Ke(a,i);K.pickSaveFile(o,l.getMessage("fileSystemPickerFiles",{types:i.toUpperCase()}),`.${i}`).then(c=>{console.log("Saving config to:",c.name),K.writeFile(c,e)}).catch(c=>{console.error("Error saving config:",c)}).finally(()=>{this.callback&&this.callback()})}async run(){console.log("Running backup"),await this.activateCliMode(),await this.sendCommand("diff all"),setTimeout(async()=>{this.sendCommand("exit",this.onClose);const e=this.outputHistory.split(`
`).slice(1).join(`
`);await this.save(e)},1500)}async activateCliMode(){return new Promise(e=>{const a=new ArrayBuffer(1),i=new Uint8Array(a);i[0]=35,g.send(a),setTimeout(()=>{this.outputHistory="",e()},500)})}async sendSerial(e,a){const i=new ArrayBuffer(e.length),o=new Uint8Array(i);for(let c=0;c<e.length;c++)o[c]=e.charCodeAt(c);g.send(i,a)}async sendCommand(e,a){this.sendSerial(`${e}
`,a)}execute(e){this.callback=e;const a=V.portPicker.selectedPort,i=V.portPicker.selectedBauds;a.startsWith("serial")?(g.addEventListener("connect",this.handleConnect.bind(this),{once:!0}),g.connect(a,{baudRate:i})):L(l.getMessage("firmwareFlasherNoPortSelected"))}}const at=new st;let X=null;function oe(r){E.read(r.detail.buffer)}class it{constructor(){this.board=A.CONFIG.boardName,this.targetAvailable=!1}verifyBoard(){const e=V.portPicker.selectedPort;if(!(f.firmware_flasher.targets?Object.keys(f.firmware_flasher.targets).length>0:!1)){console.log("Releases not loaded yet"),L(l.getMessage("firmwareFlasherNoTargetsLoaded"));return}if(g.connected||g.connectionId){console.warn("Attempting to connect while there still is a connection",g.connected,g.connectionId,g.openCanceled),g.disconnect();return}L(l.getMessage("firmwareFlasherDetectBoardQuery")),g.addEventListener("connect",this.handleConnect.bind(this),{once:!0}),g.addEventListener("disconnect",this.handleDisconnect.bind(this),{once:!0}),e.startsWith("serial")&&g.connect(e,{baudRate:115200})}handleConnect(e){this.onConnect(e.detail)}handleDisconnect(e){this.onClosed(e.detail)}onClosed(e){L(l.getMessage(e?"serialPortClosedOk":"serialPortClosedFail")),this.targetAvailable||L(l.getMessage("firmwareFlasherBoardVerificationFail")),E.clearListeners(),g.removeEventListener("receive",oe),g.removeEventListener("connect",this.handleConnect.bind(this)),g.removeEventListener("disconnect",this.handleDisconnect.bind(this))}onFinishClose(){const e=A.CONFIG.boardName;if(e){const a=$('select[name="board"]'),i=$('select[name="board"] option'),o=a.val();i.each((c,u)=>{$(u).text()===e&&(this.targetAvailable=!0)}),e!==o&&a.val(e).trigger("change"),L(l.getMessage(this.targetAvailable?"firmwareFlasherBoardVerificationSuccess":"firmwareFlasherBoardVerficationTargetNotAvailable",{boardName:e}))}g.disconnect(this.onClosed),E.disconnect_cleanup()}async getBoardInfo(){await E.promise(B.MSP_BOARD_INFO),j.gte(A.CONFIG.apiVersion,ue)&&(A.processBuildOptions(),f.firmware_flasher.cloudBuildOptions=A.CONFIG.buildOptions),this.onFinishClose()}async getCloudBuildOptions(e){f.firmware_flasher.cloudBuildOptions=e.Request.Options,await this.getBoardInfo()}async getBuildInfo(){if(j.gte(A.CONFIG.apiVersion,Ne)&&A.CONFIG.flightControllerIdentifier==="BTFL"){await E.promise(B.MSP2_GET_TEXT,X.crunch(B.MSP2_GET_TEXT,B.BUILD_KEY)),await E.promise(B.MSP2_GET_TEXT,X.crunch(B.MSP2_GET_TEXT,B.CRAFT_NAME)),await E.promise(B.MSP_BUILD_INFO),f.firmware_flasher.cloudBuildKey=A.CONFIG.buildKey;const e=new Date("3/21/2024"),a=new Date(A.CONFIG.buildInfo);if(f.firmware_flasher.validateBuildKey()&&(j.lt(A.CONFIG.apiVersion,ue)||a<e))return f.firmware_flasher.buildApi.requestBuildOptions(f.firmware_flasher.cloudBuildKey,this.getCloudBuildOptions.bind(this),this.getBoardInfo.bind(this))}await this.getBoardInfo()}async requestBoardInformation(){await E.promise(B.MSP_API_VERSION),L(l.getMessage("apiVersionReceived",A.CONFIG.apiVersion)),A.CONFIG.apiVersion.includes("null")||j.lt(A.CONFIG.apiVersion,"1.39.0")?this.onFinishClose():(await E.promise(B.MSP_FC_VARIANT),await this.getBuildInfo())}onConnect(e){e?(g.removeEventListener("receive",oe),g.addEventListener("receive",oe),X=new Se,E.listen(X.process_data.bind(X)),this.requestBoardInformation()):L(l.getMessage("serialPortOpenFail"))}}const ot=new it,M={targets:null,buildApi:new $e,sponsor:new ze,localFirmwareLoaded:!1,selectedBoard:void 0,cloudBuildKey:null,cloudBuildOptions:null,isFlashing:!1,intel_hex:void 0,parsed_hex:void 0,isConfigLocal:!1,filename:null,configFilename:null,config:{},developmentFirmwareLoaded:!1,cancelBuild:!1};M.initialize=function(r){const e=this;_.active_tab!=="firmware_flasher"&&(_.active_tab="firmware_flasher"),e.selectedBoard=void 0,e.cloudBuildKey=null,e.cloudBuildOptions=null,e.localFirmwareLoaded=!1,e.isConfigLocal=!1,e.intel_hex=void 0,e.parsed_hex=void 0;function a(){function i(s,n){je(s).then(d=>{n(d)})}function o(s){var n,d;e.filename=s,e.localFirmwareLoaded?e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",{filename:s,bytes:e.parsed_hex.bytes_total}),e.FLASH_MESSAGE_TYPES.NEUTRAL):e.flashingMessage(`<a class="save_firmware" href="#" title="Save Firmware">${l.getMessage("firmwareFlasherFirmwareOnlineLoaded",{filename:s,bytes:e.parsed_hex.bytes_total})}</a>`,e.FLASH_MESSAGE_TYPES.NEUTRAL),e.enableFlashButton(!0),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"FirmwareLoaded",{firmwareSize:e.parsed_hex.bytes_total,firmwareName:s,firmwareSource:e.localFirmwareLoaded?"file":"http",selectedTarget:(n=e.targetDetail)==null?void 0:n.target,selectedRelease:(d=e.targetDetail)==null?void 0:d.release})}function c(s){s.manufacturer?(t("div.release_info #manufacturer").text(s.manufacturer),t("div.release_info #manufacturerInfo").show()):t("div.release_info #manufacturerInfo").hide(),t("div.release_info .target").text(s.target),t("div.release_info .name").text(s.release).prop("href",s.releaseUrl),t("div.release_info .date").text(s.date),t("div.release_info #targetMCU").text(s.mcu),t("div.release_info .configFilename").text(e.isConfigLocal?e.configFilename:"[default]"),s.cloudBuild?(t("div.release_info #cloudTargetInfo").show(),t("div.release_info #cloudTargetLog").text(""),t("div.release_info #cloudTargetStatus").text("pending")):t("div.release_info #cloudTargetInfo").hide(),e.targets&&(t("div.release_info").slideDown(),t(".tab-firmware_flasher .content_wrapper").animate({scrollTop:t("div.release_info").position().top},1e3))}function u(){e.config={},e.isConfigLocal=!1,e.configFilename=null}function p(s,n){e.config=s.join(`
`),e.isConfigLocal=n!==void 0,e.configFilename=n!==void 0?n:null}function h(s,n){e.intel_hex=s,i(e.intel_hex,function(d){e.parsed_hex=d,e.parsed_hex?o(n):(e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),e.enableFlashButton(!1))})}function b(s,n){e.localFirmwareLoaded=!1,h(s,n),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline"))}function F(s){if(!s||!navigator.onLine){t('select[name="board"]').empty().append('<option value="0">Offline</option>'),t('select[name="firmware_version"]').empty().append('<option value="0">Offline</option>');return}const n=t('select[name="board"]');n.empty(),n.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectBoard")}</option>`));const d=t('select[name="firmware_version"]');d.empty(),d.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`)),Object.keys(s).sort((m,C)=>m.target-C.target).forEach(function(m,C){const S=s[m],x=t(`<option value='${S.target}'>${S.target}</option>`);n.append(x)}),f.firmware_flasher.targets=s,t("div.build_configuration").slideUp()}function k(s,n){s.empty(),n.forEach(d=>{d.default?s.append(t(`<option value='${d.value}' selected>${d.name}</option>`)):s.append(t(`<option value='${d.value}'>${d.name}</option>`))})}function O(){const s=t('select[name="radioProtocols"] option:selected').val(),n=["USE_SERIALRX_CRSF","USE_SERIALRX_FPORT","USE_SERIALRX_GHST"].includes(s);t('select[name="telemetryProtocols"]').attr("disabled",n),n?t('select[name="telemetryProtocols"] option[value="-1"]').length===0?t('select[name="telemetryProtocols"]').prepend(t("<option>",{value:"-1",selected:"selected",text:l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")})):t('select[name="telemetryProtocols"] option:first').attr("selected","selected").text(l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")):t('select[name="telemetryProtocols"] option[value="-1"]').length&&t('select[name="telemetryProtocols"] option:first').remove()}function y(s){navigator.onLine&&(k(t('select[name="radioProtocols"]'),s.radioProtocols),k(t('select[name="telemetryProtocols"]'),s.telemetryProtocols),k(t('select[name="options"]'),s.generalOptions),k(t('select[name="motorProtocols"]'),s.motorProtocols),e.validateBuildKey()||R(),O())}function R(){const s=D("ffRadioProtocol").ffRadioProtocol;s&&t('select[name="radioProtocols"] option').filter(function(d,m){return m.value===s}).length!==0&&t('select[name="radioProtocols"]').val(s)}let I;const U=t('select[name="build_type"]');function Ee(){U.empty(),I.forEach(({tag:s,title:n},d)=>{U.append(t(`<option value='${d}'>${s?l.getMessage(s):n}</option>`))})}const ne=[{tag:"firmwareFlasherOptionLabelBuildTypeRelease"},{tag:"firmwareFlasherOptionLabelBuildTypeReleaseCandidate"},{tag:"firmwareFlasherOptionLabelBuildTypeDevelopment"}];function we(){t(this).is(":checked")?t("tr.build_type").show():(t("tr.build_type").hide(),U.val(0).trigger("change"))}function Ae(){const s=t(this).is(":checked");s?I=ne:I=ne.slice(0,2),Ee(),U.val(0).trigger("change"),setTimeout(()=>{t("tr.expertOptions").toggle(s),t("div.expertOptions").toggle(s)},0),H({expertMode:s})}const Y=t(".tab-firmware_flasher input.expert_mode"),Ce=D("expertMode").expertMode;Y.prop("checked",Ce),Y.on("change",Ae).trigger("change"),t("input.show_development_releases").change(we).change(),l.localizePage(),e.sponsor.loadSponsorTile("flash",t("div.tab_sponsor")),U.on("change",function(){e.enableLoadRemoteFileButton(!1);const s=U.val();if(t('select[name="board"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),t('select[name="firmware_version"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),!_.connect_lock)try{e.buildApi.loadTargets(F)}catch(n){console.error(n)}H({selected_build_type:s})});function re(s){t("div.build_configuration").slideUp(),t("div.release_info").slideUp(),e.localFirmwareLoaded||(e.enableFlashButton(!1),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),e.parsed_hex&&e.parsed_hex.bytes_total&&(console.log("throw out loaded hex"),e.intel_hex=void 0,e.parsed_hex=void 0));const n=t('select[name="board"] option:selected').val();function d(C){if(e.targetDetail=C,C.cloudBuild===!0){t("div.build_configuration").slideDown();const S=Y.is(":checked");S&&(C.releaseType==="Unstable"?(e.buildApi.loadCommits(C.release,x=>{const v=t('select[name="commits"]');v.empty(),x.forEach(G=>{v.append(t(`<option value='${G.sha}'>${G.message}</option>`))})}),t("div.commitSelection").show()):t("div.commitSelection").hide()),t("div.expertOptions").toggle(S),t("input.corebuild_mode").trigger("change")}C.configuration&&!e.isConfigLocal&&p(C.configuration),e.enableLoadRemoteFileButton(!0)}e.buildApi.loadTarget(n,s,d);const m=()=>e.buildApi.loadOptions(s,y);e.validateBuildKey()?e.buildApi.loadOptionsByBuildKey(s,e.cloudBuildKey,y,m):m()}function Le(s,n){const d=function(C,S){return-j.compareBuild(C.release,S.release)};s.empty();const m=n.releases;if(m.length>0){s.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersionFor")} ${n.target}</option>`));const C=t('select[name="build_type"]').val();m.sort(d).filter(S=>S.type==="Unstable"&&C>1||S.type==="ReleaseCandidate"&&C>0||S.type==="Stable").forEach(function(S){const x=S.release,v=t(`<option value='${x}'>${x} [${S.label}]</option>`),G=`${n}/${S}`;v.data("summary",G),s.append(v)}),s.prop("selectedIndex",1),re(s.val())}}function le(){u(),e.intel_hex=void 0,e.parsed_hex=void 0,e.localFirmwareLoaded=!1}t('select[name="board"]').select2(),t('select[name="radioProtocols"]').select2(),t('select[name="telemetryProtocols"]').select2(),t('select[name="motorProtocols"]').select2(),t('select[name="options"]').select2({tags:!1,closeOnSelect:!1}),t('select[name="commits"]').select2({tags:!0}),t('select[name="options"]').on("select2:opening",function(){t(this).parent().find(".select2-search__field").prop("disabled",!1)}).on("select2:closing",function(){t(this).parent().find(".select2-search__field").prop("disabled",!0)}),t('select[name="radioProtocols"]').on("select2:select",function(){const s=t('select[name="radioProtocols"] option:selected').first().val();s&&H({ffRadioProtocol:s}),O()}),t('select[name="board"]').on("change",function(){e.enableLoadRemoteFileButton(!1);let s=t(this).val();if(s===null&&(s="0",t(this).val(s).trigger("change")),!_.connect_lock){e.selectedBoard=s,console.log("board changed to",s),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t("div.release_info").slideUp(),t("div.build_configuration").slideUp(),e.localFirmwareLoaded||e.enableFlashButton(!1);const n=t('select[name="firmware_version"]');s==="0"?(le(),n.empty(),n.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`))):(n.empty(),n.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),e.buildApi.loadTargetReleases(s,d=>Le(n,d)))}});const ye=['select[name="board"]','select[name="radioProtocols"]','select[name="telemetryProtocols"]','select[name="motorProtocols"]','select[name="options"]','select[name="commits"]'];t(document).on("select2:open",ye.join(","),()=>{const s=document.querySelectorAll(".select2-container--open .select2-search__field");t(this).one("mouseup keyup",()=>{setTimeout(()=>{s[s.length-1].focus()},0)})});function Me(s){let n=[],d=!1;for(let m=0;m<s.length;m++){if((s.charAt(m)===`
`||s.charAt(m)==="\r")&&(d=!1),s.charAt(m)==="#"&&(d=!0),!d&&s.charCodeAt(m)>255)return e.flashingMessage(l.getMessage("firmwareFlasherConfigCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),L(l.getMessage("firmwareFlasherConfigCorruptedLogMessage")),null;s.charCodeAt(m)>255?n.push("_"):n.push(s.charAt(m))}return n.join("").split(`
`)}function Te(s){const n=t("input.flash_on_connect").is(":checked");console.log("Detected USB device:",s),console.log("Reboot mode: %s, flash on connect",J.rebootMode,n),(J.rebootMode||n)&&(J.rebootMode=0,_.connect_lock=!1,Q())}De.$on("port-handler:auto-select-usb-device",Te);function ke(s){const n={};(t("input.erase_chip").is(":checked")||Y.is(":not(:checked)"))&&(n.erase_chip=!0);const d=V.portPicker.selectedPort,m=d.startsWith("serial_"),C=d.startsWith("usb_");if(console.log("Selected port:",d),C)N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"DFU Flashing",{filename:e.filename||null}),z.connect(d,s,n);else if(m){t("input.updating").is(":checked")?n.no_reboot=!0:n.reboot_baud=V.portPicker.selectedBauds;let S=115200;t("input.flash_manual_baud").is(":checked")&&(S=parseInt(t("#flash_manual_baud_rate").val())||115200),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"Flashing",{filename:e.filename||null}),J.connect(d,S,s,n)}else console.log("No valid port detected, asking for permissions"),z.requestPermission().then(S=>{z.connect(S.path,s,n)});e.isFlashing=!1}let T=D("erase_chip");t("input.erase_chip").prop("checked",T.erase_chip),t("input.erase_chip").change(function(){H({erase_chip:t(this).is(":checked")})}).change(),T=D("show_development_releases"),t("input.show_development_releases").prop("checked",T.show_development_releases).change(function(){H({show_development_releases:t(this).is(":checked")})}).change(),T=D("selected_build_type"),U.val(T.selected_build_type||0).trigger("change"),T=D("no_reboot_sequence"),T.no_reboot_sequence?(t("input.updating").prop("checked",!0),t(".flash_on_connect_wrapper").show()):t("input.updating").prop("checked",!1),t("input.updating").change(function(){const s=t(this).is(":checked");s?t(".flash_on_connect_wrapper").show():(t("input.flash_on_connect").prop("checked",!1).change(),t(".flash_on_connect_wrapper").hide()),H({no_reboot_sequence:s})}),t("input.updating").change(),T=D("flash_manual_baud"),T.flash_manual_baud?t("input.flash_manual_baud").prop("checked",!0):t("input.flash_manual_baud").prop("checked",!1),t("input.corebuild_mode").change(function(){const s=t(this).is(":checked");t(".hide-in-core-build-mode").toggle(!s),t("div.expertOptions").toggle(!s&&Y.is(":checked"))}),t("input.corebuild_mode").change(),t("input.flash_manual_baud").change(function(){const s=t(this).is(":checked");H({flash_manual_baud:s})}),t("input.flash_manual_baud").change(),T=D("flash_manual_baud_rate"),t("#flash_manual_baud_rate").val(T.flash_manual_baud_rate),t("#flash_manual_baud_rate").change(function(){const s=parseInt(t("#flash_manual_baud_rate").val());H({flash_manual_baud_rate:s})}),t("input.flash_manual_baud_rate").change(),t("a.load_file").on("click",function(){e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.developmentFirmwareLoaded=!1,K.pickOpenFile(l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log("Saving firmware to:",s.name),K.readFile(s).then(n=>{if(s.name.split(".").pop()==="hex")e.intel_hex=n,i(e.intel_hex,function(d){e.parsed_hex=d,e.parsed_hex?(e.localFirmwareLoaded=!0,o(s.name)):e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID)});else{le();let d=Me(n);d!==null&&(p(d,s.name),e.isConfigLocal&&!e.parsed_hex&&e.flashingMessage(l.getMessage("firmwareFlasherLoadedConfig"),e.FLASH_MESSAGE_TYPES.NEUTRAL),(e.isConfigLocal&&e.parsed_hex&&!e.localFirmwareLoaded||e.localFirmwareLoaded)&&(e.enableFlashButton(!0),e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",e.parsed_hex.bytes_total),e.FLASH_MESSAGE_TYPES.NEUTRAL)))}})}).catch(s=>{console.error("Error reading file:",s)})}),t('select[name="firmware_version"]').change(s=>{re(t("option:selected",s.target).val())}),t("a.cloud_build_cancel").on("click",function(s){t("a.cloud_build_cancel").toggleClass("disabled",!0),e.cancelBuild=!0}),t("a.load_remote_file").on("click",function(s){if(!e.selectedBoard)return;if(e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.localFirmwareLoaded=!1,e.developmentFirmwareLoaded=I[t('select[name="build_type"]').val()].tag==="firmwareFlasherOptionLabelBuildTypeDevelopment",t('select[name="firmware_version"]').val()==="0"){L(l.getMessage("firmwareFlasherNoFirmwareSelected"));return}function n(){t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline")),l.localizePage()}function d(x,v,G,w){w===!0&&t("div.release_info #cloudTargetLog").text(l.getMessage("firmwareFlasherCloudBuildLogUrl")).prop("href",`https://build.betaflight.com/api/builds/${v}/log`),t("div.release_info #cloudTargetStatus").text(l.getMessage(`firmwareFlasherCloudBuild${x}`)),t(".buildProgress").val(G)}function m(x,v,G){v.status==="success"&&(d(`Success${G}`,x.key,100,!0),v.configuration!==void 0&&!e.isConfigLocal&&p(v.configuration),e.buildApi.loadTargetHex(x.url,w=>b(w,x.file),n))}function C(x,v){d(`Fail${v}`,x,0,!0),n()}function S(x){let v={target:x.target,release:x.release,options:[]};(x.cloudBuild!==!0||t('input[name="coreBuildModeCheckbox"]').is(":checked"))===!0?v.options.push("CORE_BUILD"):(v.options.push("CLOUD_BUILD"),t('select[name="radioProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="telemetryProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="options"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="motorProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('input[name="expertModeCheckbox"]').is(":checked")&&(x.releaseType==="Unstable"&&(v.commit=t('select[name="commits"] option:selected').val()),t('input[name="customDefines"]').val().split(" ").map(w=>w.trim()).forEach(w=>{v.options.push(w)}))),console.info("Build request:",v),e.buildApi.requestBuild(v,w=>{if(console.info("Build response:",w),e.targetDetail.file=w.file,!x.cloudBuild){e.buildApi.loadTargetHex(w.url,Z=>b(Z,w.file),n);return}d("Pending",w.key,0,!1),e.cancelBuild=!1,e.buildApi.requestBuildStatus(w.key,Z=>{if(Z.status==="success"){m(w,Z,"Cached");return}e.enableCancelBuildButton(!0);const de=5;let q=1,te=!1,fe=120;const Pe=setInterval(()=>{e.buildApi.requestBuildStatus(w.key,W=>{W.timeOut!==void 0&&(te||(te=!0,q=1),fe=W.timeOut);const se=fe/de;if(W.status!=="queued"||q>se||e.cancelBuild){if(e.enableCancelBuildButton(!1),clearInterval(Pe),W.status==="success"){m(w,W,"");return}let ae="";q>se&&(ae="TimeOut"),e.cancelBuild&&(ae="Cancel"),C(w.key,ae);return}te&&d("Processing",w.key,q*(100/se),!1),q++})},de*1e3)})},()=>{d("FailRequest","",0,!1),n()})}e.targetDetail?(t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonDownloading")),e.enableLoadRemoteFileButton(!1),c(e.targetDetail),S(e.targetDetail)):(t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),l.localizePage())}),t("a.exit_dfu").on("click",function(){if(e.enableDfuExitButton(!1),!_.connect_lock){N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"ExitDfu",null);try{console.log("Closing DFU"),z.requestPermission().then(s=>{z.connect(s.path,e.parsed_hex,{exitDfu:!0})})}catch(s){console.log(`Exiting DFU failed: ${s.message}`)}}});const ce=t("#targetSupportInfoUrl");ce.on("click",function(){let s="https://betaflight.com/docs/wiki/boards/archive/Missing";const n=`https://betaflight.com/docs/wiki/boards/current/${e.selectedBoard}`;Ge(n)&&(s=n),ce.attr("href",s)});const ee=t("a.detect-board");ee.on("click",()=>{ee.toggleClass("disabled",!0),_.connect_lock||ot.verifyBoard(V.portPicker.selectedPort),setTimeout(()=>ee.toggleClass("disabled",!1),2e3)}),t("a.flash_firmware").on("click",function(){e.isFlashing=!0;const s=t("input.flash_on_connect").is(":checked");e.enableFlashButton(!1),e.enableDfuExitButton(!1),e.enableLoadRemoteFileButton(!1),e.enableLoadFileButton(!1);function n(){e.developmentFirmwareLoaded&&!s?Be():Q()}s||!(V.portAvailable||_.connect_lock)?n():_.showYesNoDialog({title:l.getMessage("firmwareFlasherRemindBackupTitle"),text:l.getMessage("firmwareFlasherRemindBackup"),buttonYesText:l.getMessage("firmwareFlasherBackup"),buttonNoText:l.getMessage("firmwareFlasherBackupIgnore"),buttonYesCallback:()=>{_.connect_lock=!0,at.execute(()=>{_.connect_lock=!1,n()})},buttonNoCallback:n})});function Be(){const n="lastDevelopmentWarningTimestamp";function d(){const m={};m[n]=Date.now(),Ve(m)}T=He(n),!T[n]||Date.now()-T[n]>864e5?Ie(d):Q()}function Ie(s){const n=t("#dialogUnstableFirmwareAcknowledgement")[0],d=t("#dialogUnstableFirmwareAcknowledgement-flashbtn"),m=t('input[name="dialogUnstableFirmwareAcknowledgement-acknowledge"]');m.change(function(){t(this).is(":checked")?d.removeClass("disabled"):d.addClass("disabled")}),d.click(function(){n.close(),m.is(":checked")&&(s&&s(),Q())}),t("#dialogUnstableFirmwareAcknowledgement-cancelbtn").click(function(){n.close()}),n.addEventListener("close",function(){m.prop("checked",!1).change()}),n.showModal()}function Q(){if(!_.connect_lock)if(e.parsed_hex){try{e.config&&!e.parsed_hex.configInserted&&(new Xe().insertConfig(e.parsed_hex,e.config)?e.parsed_hex.configInserted=!0:(console.log("Firmware does not support custom defaults."),u())),ke(e.parsed_hex)}catch(s){console.log(`Flashing failed: ${s.message}`)}t("input.flash_on_connect").prop("checked",!1).change()}else t("span.progressLabel").attr("i18n","firmwareFlasherFirmwareNotLoaded").removeClass("i18n-replaced"),l.localizePage()}t("span.progressLabel").on("click","a.save_firmware",function(){K.pickSaveFile(e.targetDetail.file,l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log("Saving firmware to:",s.name),K.writeFile(s,e.intel_hex),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"SaveFirmware")}).catch(s=>{console.error("Error saving file:",s)})}),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),V.dfuAvailable&&t("a.exit_dfu").removeClass("disabled"),_.content_ready(r)}e.buildApi.loadTargets(()=>{t("#content").load("./tabs/firmware_flasher.html",a)})};M.validateBuildKey=function(){var r;return((r=this.cloudBuildKey)==null?void 0:r.length)===32&&navigator.onLine};M.cleanup=function(r){t(document).unbind("keypress"),t(document).off("click","span.progressLabel a"),r&&r()};M.enableCancelBuildButton=function(r){t("a.cloud_build_cancel").toggleClass("disabled",!r),self.cancelBuild=!1};M.enableFlashButton=function(r){t("a.flash_firmware").toggleClass("disabled",!r)};M.enableLoadRemoteFileButton=function(r){t("a.load_remote_file").toggleClass("disabled",!r)};M.enableLoadFileButton=function(r){t("a.load_file").toggleClass("disabled",!r)};M.enableDfuExitButton=function(r){t("a.exit_dfu").toggleClass("disabled",!r)};M.refresh=function(r){const e=this;_.tab_switch_cleanup(function(){e.initialize(),r&&r()})};M.showDialogVerifyBoard=function(r,e,a,i){const o=t("#dialog-verify-board")[0];t("#dialog-verify-board-content").html(l.getMessage("firmwareFlasherVerifyBoard",{selected_board:r,verified_board:e})),o.hasAttribute("open")||(o.showModal(),t("#dialog-verify-board-continue-confirmbtn").on("click",function(){o.close(),a()}),t("#dialog-verify-board-abort-confirmbtn").on("click",function(){o.close(),i()}))};M.FLASH_MESSAGE_TYPES={NEUTRAL:"NEUTRAL",VALID:"VALID",INVALID:"INVALID",ACTION:"ACTION"};M.flashingMessage=function(r,e){let a=this,i=t("span.progressLabel");switch(e){case a.FLASH_MESSAGE_TYPES.VALID:i.removeClass("invalid actionRequired").addClass("valid");break;case a.FLASH_MESSAGE_TYPES.INVALID:i.removeClass("valid actionRequired").addClass("invalid");break;case a.FLASH_MESSAGE_TYPES.ACTION:i.removeClass("valid invalid").addClass("actionRequired");break;case a.FLASH_MESSAGE_TYPES.NEUTRAL:default:i.removeClass("valid invalid actionRequired");break}return r!==null&&i.html(r),a};M.flashProgress=function(r){return t(".progress").val(r),this};M.injectTargetInfo=function(r,e,a,i){const o=/^# config: manufacturer_id: .*, board_name: .*, version: .*$, date: .*\n/gm,c=r.replace(o,""),u=`# config: manufacturer_id: ${a}, board_name: ${e}, version: ${i.commitHash}, date: ${i.date}`,p=c.split(`
`);return p.splice(1,0,u),p.join(`
`)};f.firmware_flasher=M;export{M as firmware_flasher};
